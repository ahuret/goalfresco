/*
Alfresco Content Services REST API

**Core API**  Provides access to the core features of Alfresco Content Services. 

API version: 1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// GroupsApiService GroupsApi service
type GroupsApiService service

type ApiCreateGroupRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	groupBodyCreate *GroupBodyCreate
	include *[]string
	fields *[]string
}

// The group to create.
func (r ApiCreateGroupRequest) GroupBodyCreate(groupBodyCreate GroupBodyCreate) ApiCreateGroupRequest {
	r.groupBodyCreate = &groupBodyCreate
	return r
}

// Returns additional information about the group. The following optional fields can be requested: * parentIds * zones 
func (r ApiCreateGroupRequest) Include(include []string) ApiCreateGroupRequest {
	r.include = &include
	return r
}

// A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. 
func (r ApiCreateGroupRequest) Fields(fields []string) ApiCreateGroupRequest {
	r.fields = &fields
	return r
}

func (r ApiCreateGroupRequest) Execute() (*GroupEntry, *http.Response, error) {
	return r.ApiService.CreateGroupExecute(r)
}

/*
CreateGroup Create a group

**Note:** this endpoint is available in Alfresco 5.2.1 and newer versions.

Create a group.

The group id must start with "GROUP\_". If this is omitted it will be added automatically.
This format is also returned when listing groups or group memberships. It should be noted
that the other group-related operations also expect the id to start with "GROUP\_".

If one or more parentIds are specified then the group will be created and become a member
of each of the specified parent groups.

If no parentIds are specified then the group will be created as a root group.

The group will be created in the **APP.DEFAULT** and **AUTH.ALF** zones.

You must have admin rights to create a group.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGroupRequest
*/
func (a *GroupsApiService) CreateGroup(ctx context.Context) ApiCreateGroupRequest {
	return ApiCreateGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GroupEntry
func (a *GroupsApiService) CreateGroupExecute(r ApiCreateGroupRequest) (*GroupEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.CreateGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupBodyCreate == nil {
		return localVarReturnValue, nil, reportError("groupBodyCreate is required and must be specified")
	}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupBodyCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateGroupMembershipRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	groupId string
	groupMembershipBodyCreate *GroupMembershipBodyCreate
	fields *[]string
}

// The group membership to add (person or sub-group).
func (r ApiCreateGroupMembershipRequest) GroupMembershipBodyCreate(groupMembershipBodyCreate GroupMembershipBodyCreate) ApiCreateGroupMembershipRequest {
	r.groupMembershipBodyCreate = &groupMembershipBodyCreate
	return r
}

// A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. 
func (r ApiCreateGroupMembershipRequest) Fields(fields []string) ApiCreateGroupMembershipRequest {
	r.fields = &fields
	return r
}

func (r ApiCreateGroupMembershipRequest) Execute() (*GroupMemberEntry, *http.Response, error) {
	return r.ApiService.CreateGroupMembershipExecute(r)
}

/*
CreateGroupMembership Create a group membership

**Note:** this endpoint is available in Alfresco 5.2.1 and newer versions.

Create a group membership (for an existing person or group) within a group **groupId**.

If the added group was previously a root group then it becomes a non-root group since it now has a parent.

It is an error to specify an **id** that does not exist.

You must have admin rights to create a group membership.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The identifier of a group.
 @return ApiCreateGroupMembershipRequest
*/
func (a *GroupsApiService) CreateGroupMembership(ctx context.Context, groupId string) ApiCreateGroupMembershipRequest {
	return ApiCreateGroupMembershipRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return GroupMemberEntry
func (a *GroupsApiService) CreateGroupMembershipExecute(r ApiCreateGroupMembershipRequest) (*GroupMemberEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupMemberEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.CreateGroupMembership")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{groupId}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupMembershipBodyCreate == nil {
		return localVarReturnValue, nil, reportError("groupMembershipBodyCreate is required and must be specified")
	}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupMembershipBodyCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteGroupRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	groupId string
	cascade *bool
}

// If **true** then the delete will be applied in cascade to sub-groups. 
func (r ApiDeleteGroupRequest) Cascade(cascade bool) ApiDeleteGroupRequest {
	r.cascade = &cascade
	return r
}

func (r ApiDeleteGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteGroupExecute(r)
}

/*
DeleteGroup Delete a group

**Note:** this endpoint is available in Alfresco 5.2.1 and newer versions.

Delete group **groupId**.

The option to cascade delete applies this recursively to any hierarchy of group members.
In this case, removing a group member does not delete the person or sub-group itself.
If a removed sub-group no longer has any parent groups then it becomes a root group.

You must have admin rights to delete a group.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The identifier of a group.
 @return ApiDeleteGroupRequest
*/
func (a *GroupsApiService) DeleteGroup(ctx context.Context, groupId string) ApiDeleteGroupRequest {
	return ApiDeleteGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *GroupsApiService) DeleteGroupExecute(r ApiDeleteGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.DeleteGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cascade != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cascade", r.cascade, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteGroupMembershipRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	groupId string
	groupMemberId string
}

func (r ApiDeleteGroupMembershipRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteGroupMembershipExecute(r)
}

/*
DeleteGroupMembership Delete a group membership

**Note:** this endpoint is available in Alfresco 5.2.1 and newer versions.

Delete group member **groupMemberId** (person or sub-group) from group **groupId**.

Removing a group member does not delete the person or sub-group itself.

If a removed sub-group no longer has any parent groups then it becomes a root group.

You must have admin rights to delete a group membership.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The identifier of a group.
 @param groupMemberId The identifier of a person or group.
 @return ApiDeleteGroupMembershipRequest
*/
func (a *GroupsApiService) DeleteGroupMembership(ctx context.Context, groupId string, groupMemberId string) ApiDeleteGroupMembershipRequest {
	return ApiDeleteGroupMembershipRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		groupMemberId: groupMemberId,
	}
}

// Execute executes the request
func (a *GroupsApiService) DeleteGroupMembershipExecute(r ApiDeleteGroupMembershipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.DeleteGroupMembership")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{groupId}/members/{groupMemberId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupMemberId"+"}", url.PathEscape(parameterValueToString(r.groupMemberId, "groupMemberId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetGroupRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	groupId string
	include *[]string
	fields *[]string
}

// Returns additional information about the group. The following optional fields can be requested: * parentIds * zones 
func (r ApiGetGroupRequest) Include(include []string) ApiGetGroupRequest {
	r.include = &include
	return r
}

// A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. 
func (r ApiGetGroupRequest) Fields(fields []string) ApiGetGroupRequest {
	r.fields = &fields
	return r
}

func (r ApiGetGroupRequest) Execute() (*GroupEntry, *http.Response, error) {
	return r.ApiService.GetGroupExecute(r)
}

/*
GetGroup Get group details

**Note:** this endpoint is available in Alfresco 5.2.1 and newer versions.

Get details for group **groupId**.

You can use the **include** parameter to return additional information.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The identifier of a group.
 @return ApiGetGroupRequest
*/
func (a *GroupsApiService) GetGroup(ctx context.Context, groupId string) ApiGetGroupRequest {
	return ApiGetGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return GroupEntry
func (a *GroupsApiService) GetGroupExecute(r ApiGetGroupRequest) (*GroupEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GetGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGroupMembershipsRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	groupId string
	skipCount *int32
	maxItems *int32
	orderBy *[]string
	where *string
	fields *[]string
}

// The number of entities that exist in the collection before those included in this list. If not supplied then the default value is 0. 
func (r ApiListGroupMembershipsRequest) SkipCount(skipCount int32) ApiListGroupMembershipsRequest {
	r.skipCount = &skipCount
	return r
}

// The maximum number of items to return in the list. If not supplied then the default value is 100. 
func (r ApiListGroupMembershipsRequest) MaxItems(maxItems int32) ApiListGroupMembershipsRequest {
	r.maxItems = &maxItems
	return r
}

// A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. 
func (r ApiListGroupMembershipsRequest) OrderBy(orderBy []string) ApiListGroupMembershipsRequest {
	r.orderBy = &orderBy
	return r
}

// A string to restrict the returned objects by using a predicate.
func (r ApiListGroupMembershipsRequest) Where(where string) ApiListGroupMembershipsRequest {
	r.where = &where
	return r
}

// A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. 
func (r ApiListGroupMembershipsRequest) Fields(fields []string) ApiListGroupMembershipsRequest {
	r.fields = &fields
	return r
}

func (r ApiListGroupMembershipsRequest) Execute() (*GroupMemberPaging, *http.Response, error) {
	return r.ApiService.ListGroupMembershipsExecute(r)
}

/*
ListGroupMemberships List memberships of a group

**Note:** this endpoint is available in Alfresco 5.2.1 and newer versions.

Gets a list of the group memberships for the group **groupId**.

You can use the **where** parameter to filter the returned groups by **memberType**.

Example to filter by **memberType**, use any one of:

```
(memberType='GROUP')
(memberType='PERSON')
```

The default sort order for the returned list is for group members to be sorted by ascending displayName.
You can override the default by using the **orderBy** parameter. You can specify one of the following fields in the **orderBy** parameter:
* id
* displayName


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The identifier of a group.
 @return ApiListGroupMembershipsRequest
*/
func (a *GroupsApiService) ListGroupMemberships(ctx context.Context, groupId string) ApiListGroupMembershipsRequest {
	return ApiListGroupMembershipsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return GroupMemberPaging
func (a *GroupsApiService) ListGroupMembershipsExecute(r ApiListGroupMembershipsRequest) (*GroupMemberPaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupMemberPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.ListGroupMemberships")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{groupId}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.skipCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipCount", r.skipCount, "")
	}
	if r.maxItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxItems", r.maxItems, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "csv")
	}
	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGroupMembershipsForPersonRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	personId string
	skipCount *int32
	maxItems *int32
	orderBy *[]string
	include *[]string
	where *string
	fields *[]string
}

// The number of entities that exist in the collection before those included in this list. If not supplied then the default value is 0. 
func (r ApiListGroupMembershipsForPersonRequest) SkipCount(skipCount int32) ApiListGroupMembershipsForPersonRequest {
	r.skipCount = &skipCount
	return r
}

// The maximum number of items to return in the list. If not supplied then the default value is 100. 
func (r ApiListGroupMembershipsForPersonRequest) MaxItems(maxItems int32) ApiListGroupMembershipsForPersonRequest {
	r.maxItems = &maxItems
	return r
}

// A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. 
func (r ApiListGroupMembershipsForPersonRequest) OrderBy(orderBy []string) ApiListGroupMembershipsForPersonRequest {
	r.orderBy = &orderBy
	return r
}

// Returns additional information about the group. The following optional fields can be requested: * parentIds * zones 
func (r ApiListGroupMembershipsForPersonRequest) Include(include []string) ApiListGroupMembershipsForPersonRequest {
	r.include = &include
	return r
}

// A string to restrict the returned objects by using a predicate.
func (r ApiListGroupMembershipsForPersonRequest) Where(where string) ApiListGroupMembershipsForPersonRequest {
	r.where = &where
	return r
}

// A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. 
func (r ApiListGroupMembershipsForPersonRequest) Fields(fields []string) ApiListGroupMembershipsForPersonRequest {
	r.fields = &fields
	return r
}

func (r ApiListGroupMembershipsForPersonRequest) Execute() (*GroupPaging, *http.Response, error) {
	return r.ApiService.ListGroupMembershipsForPersonExecute(r)
}

/*
ListGroupMembershipsForPerson List group memberships

**Note:** this endpoint is available in Alfresco 5.2.1 and newer versions.

 Gets a list of group membership information for person **personId**.

 You can use the `-me-` string in place of `<personId>` to specify the currently authenticated user.

 You can use the **include** parameter to return additional information.

 You can use the **where** parameter to filter the returned groups by **isRoot**. For example, the following **where**
 clause will return just the root groups:

 ```
 (isRoot=true)
 ```

 The **where** parameter can also be used to filter by ***zone***. This may be combined with isRoot to narrow
 a result set even further. For example, the following where clause will only return groups belonging to the
 `MY.ZONE` zone.

 ```
 where=(zones in ('MY.ZONE'))
 ```

 This may be combined with the isRoot filter, as shown below:

 ```
 where=(isRoot=false AND zones in ('MY.ZONE'))
 ```

 ***Note:*** restrictions include
 * `AND` is the only supported operator when combining `isRoot` and `zones` filters
 * Only one zone is supported by the filter
 * The quoted zone name must be placed in parenthesis â€” a 400 error will result if these are omitted.


 The default sort order for the returned list is for groups to be sorted by ascending displayName.
 You can override the default by using the **orderBy** parameter. You can specify one or more of the following fields in the **orderBy** parameter:
 * id
 * displayName


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param personId The identifier of a person.
 @return ApiListGroupMembershipsForPersonRequest
*/
func (a *GroupsApiService) ListGroupMembershipsForPerson(ctx context.Context, personId string) ApiListGroupMembershipsForPersonRequest {
	return ApiListGroupMembershipsForPersonRequest{
		ApiService: a,
		ctx: ctx,
		personId: personId,
	}
}

// Execute executes the request
//  @return GroupPaging
func (a *GroupsApiService) ListGroupMembershipsForPersonExecute(r ApiListGroupMembershipsForPersonRequest) (*GroupPaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.ListGroupMembershipsForPerson")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/people/{personId}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", url.PathEscape(parameterValueToString(r.personId, "personId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.skipCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipCount", r.skipCount, "")
	}
	if r.maxItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxItems", r.maxItems, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGroupsRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	skipCount *int32
	maxItems *int32
	orderBy *[]string
	include *[]string
	where *string
	fields *[]string
}

// The number of entities that exist in the collection before those included in this list. If not supplied then the default value is 0. 
func (r ApiListGroupsRequest) SkipCount(skipCount int32) ApiListGroupsRequest {
	r.skipCount = &skipCount
	return r
}

// The maximum number of items to return in the list. If not supplied then the default value is 100. 
func (r ApiListGroupsRequest) MaxItems(maxItems int32) ApiListGroupsRequest {
	r.maxItems = &maxItems
	return r
}

// A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. 
func (r ApiListGroupsRequest) OrderBy(orderBy []string) ApiListGroupsRequest {
	r.orderBy = &orderBy
	return r
}

// Returns additional information about the group. The following optional fields can be requested: * parentIds * zones 
func (r ApiListGroupsRequest) Include(include []string) ApiListGroupsRequest {
	r.include = &include
	return r
}

// A string to restrict the returned objects by using a predicate.
func (r ApiListGroupsRequest) Where(where string) ApiListGroupsRequest {
	r.where = &where
	return r
}

// A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. 
func (r ApiListGroupsRequest) Fields(fields []string) ApiListGroupsRequest {
	r.fields = &fields
	return r
}

func (r ApiListGroupsRequest) Execute() (*GroupPaging, *http.Response, error) {
	return r.ApiService.ListGroupsExecute(r)
}

/*
ListGroups List groups

**Note:** this endpoint is available in Alfresco 5.2.1 and newer versions.

Gets a list of groups.

You can use the **include** parameter to return additional information.

You can use the **where** parameter to filter the returned groups by **isRoot**. For example, the following **where**
clause will return just the root groups:

```
(isRoot=true)
```

The **where** parameter can also be used to filter by ***zone*** and ***displayName***.
They may be combined with isRoot to narrow a result set even further. 
For example, the following where clause will only return groups belonging to the `MY.ZONE` zone.

```
where=(zones in ('MY.ZONE'))
```

This may be combined with the isRoot filter, as shown below:

```
where=(isRoot=false AND zones in ('MY.ZONE'))
```
The following where clause will only return groups with displayName `MY.GROUP.NAME`. 

```
where=(displayName in ('MY.GROUP.NAME'))
```
This may be combined with the isRoot and zones filter, as shown below:

```
where=(isRoot=false AND displayName in ('MY.GROUP.NAME'))
```

```
where=(zones in ('MY.ZONE') AND displayName in ('MY.GROUP.NAME'))
```

```
where=(isRoot=false AND zones in ('MY.ZONE') AND displayName in ('MY.GROUP.NAME'))
```

***Note:*** restrictions include
* `AND` is the only supported operator when combining `isRoot`, `zones` and `displayName` filters
* Only one zone is supported by the filter
* Only one displayName is supported by the filter
* The quoted zone name and displayName must be placed in parenthesis â€” a 400 error will result if these are omitted.

The default sort order for the returned list is for groups to be sorted by ascending displayName.
You can override the default by using the **orderBy** parameter. You can specify one of the following fields in the **orderBy** parameter:
* id
* displayName


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListGroupsRequest
*/
func (a *GroupsApiService) ListGroups(ctx context.Context) ApiListGroupsRequest {
	return ApiListGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GroupPaging
func (a *GroupsApiService) ListGroupsExecute(r ApiListGroupsRequest) (*GroupPaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.ListGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.skipCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipCount", r.skipCount, "")
	}
	if r.maxItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxItems", r.maxItems, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGroupRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	groupId string
	groupBodyUpdate *GroupBodyUpdate
	include *[]string
	fields *[]string
}

// The group information to update.
func (r ApiUpdateGroupRequest) GroupBodyUpdate(groupBodyUpdate GroupBodyUpdate) ApiUpdateGroupRequest {
	r.groupBodyUpdate = &groupBodyUpdate
	return r
}

// Returns additional information about the group. The following optional fields can be requested: * parentIds * zones 
func (r ApiUpdateGroupRequest) Include(include []string) ApiUpdateGroupRequest {
	r.include = &include
	return r
}

// A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. 
func (r ApiUpdateGroupRequest) Fields(fields []string) ApiUpdateGroupRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateGroupRequest) Execute() (*GroupEntry, *http.Response, error) {
	return r.ApiService.UpdateGroupExecute(r)
}

/*
UpdateGroup Update group details

**Note:** this endpoint is available in Alfresco 5.2.1 and newer versions.

Update details (displayName) for group **groupId**.

You must have admin rights to update a group.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The identifier of a group.
 @return ApiUpdateGroupRequest
*/
func (a *GroupsApiService) UpdateGroup(ctx context.Context, groupId string) ApiUpdateGroupRequest {
	return ApiUpdateGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return GroupEntry
func (a *GroupsApiService) UpdateGroupExecute(r ApiUpdateGroupRequest) (*GroupEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.UpdateGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupBodyUpdate == nil {
		return localVarReturnValue, nil, reportError("groupBodyUpdate is required and must be specified")
	}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupBodyUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
