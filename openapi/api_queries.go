/*
Alfresco Content Services REST API

**Core API**  Provides access to the core features of Alfresco Content Services. 

API version: 1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// QueriesApiService QueriesApi service
type QueriesApiService service

type ApiFindNodesRequest struct {
	ctx context.Context
	ApiService *QueriesApiService
	term *string
	rootNodeId *string
	skipCount *int32
	maxItems *int32
	nodeType *string
	include *[]string
	orderBy *[]string
	fields *[]string
}

// The term to search for.
func (r ApiFindNodesRequest) Term(term string) ApiFindNodesRequest {
	r.term = &term
	return r
}

// The id of the node to start the search from.  Supports the aliases -my-, -root- and -shared-. 
func (r ApiFindNodesRequest) RootNodeId(rootNodeId string) ApiFindNodesRequest {
	r.rootNodeId = &rootNodeId
	return r
}

// The number of entities that exist in the collection before those included in this list. If not supplied then the default value is 0. 
func (r ApiFindNodesRequest) SkipCount(skipCount int32) ApiFindNodesRequest {
	r.skipCount = &skipCount
	return r
}

// The maximum number of items to return in the list. If not supplied then the default value is 100. 
func (r ApiFindNodesRequest) MaxItems(maxItems int32) ApiFindNodesRequest {
	r.maxItems = &maxItems
	return r
}

// Restrict the returned results to only those of the given node type and its sub-types 
func (r ApiFindNodesRequest) NodeType(nodeType string) ApiFindNodesRequest {
	r.nodeType = &nodeType
	return r
}

// Returns additional information about the node. The following optional fields can be requested: * allowableOperations * aspectNames * isLink * isFavorite * isLocked * path * properties 
func (r ApiFindNodesRequest) Include(include []string) ApiFindNodesRequest {
	r.include = &include
	return r
}

// A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. 
func (r ApiFindNodesRequest) OrderBy(orderBy []string) ApiFindNodesRequest {
	r.orderBy = &orderBy
	return r
}

// A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. 
func (r ApiFindNodesRequest) Fields(fields []string) ApiFindNodesRequest {
	r.fields = &fields
	return r
}

func (r ApiFindNodesRequest) Execute() (*NodePaging, *http.Response, error) {
	return r.ApiService.FindNodesExecute(r)
}

/*
FindNodes Find nodes

**Note:** this endpoint is available in Alfresco 5.2 and newer versions.

Gets a list of nodes that match the given search criteria.

The search term is used to look for nodes that match against name, title, description, full text content or tags.

The search term:
- must contain a minimum of 3 alphanumeric characters
- allows "quoted term"
- can optionally use '*' for wildcard matching

By default, file and folder types will be searched unless a specific type is provided as a query parameter.

By default, the search will be across the repository unless a specific root node id is provided to start the search from.

You can sort the result list using the **orderBy** parameter. You can specify one or more of the following fields in the **orderBy** parameter:
* name
* modifiedAt
* createdAt


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFindNodesRequest
*/
func (a *QueriesApiService) FindNodes(ctx context.Context) ApiFindNodesRequest {
	return ApiFindNodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NodePaging
func (a *QueriesApiService) FindNodesExecute(r ApiFindNodesRequest) (*NodePaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NodePaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueriesApiService.FindNodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queries/nodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.term == nil {
		return localVarReturnValue, nil, reportError("term is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "term", r.term, "")
	if r.rootNodeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootNodeId", r.rootNodeId, "")
	}
	if r.skipCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipCount", r.skipCount, "")
	}
	if r.maxItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxItems", r.maxItems, "")
	}
	if r.nodeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeType", r.nodeType, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "csv")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindPeopleRequest struct {
	ctx context.Context
	ApiService *QueriesApiService
	term *string
	skipCount *int32
	maxItems *int32
	fields *[]string
	orderBy *[]string
}

// The term to search for. 
func (r ApiFindPeopleRequest) Term(term string) ApiFindPeopleRequest {
	r.term = &term
	return r
}

// The number of entities that exist in the collection before those included in this list. If not supplied then the default value is 0. 
func (r ApiFindPeopleRequest) SkipCount(skipCount int32) ApiFindPeopleRequest {
	r.skipCount = &skipCount
	return r
}

// The maximum number of items to return in the list. If not supplied then the default value is 100. 
func (r ApiFindPeopleRequest) MaxItems(maxItems int32) ApiFindPeopleRequest {
	r.maxItems = &maxItems
	return r
}

// A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. 
func (r ApiFindPeopleRequest) Fields(fields []string) ApiFindPeopleRequest {
	r.fields = &fields
	return r
}

// A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. 
func (r ApiFindPeopleRequest) OrderBy(orderBy []string) ApiFindPeopleRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiFindPeopleRequest) Execute() (*PersonPaging, *http.Response, error) {
	return r.ApiService.FindPeopleExecute(r)
}

/*
FindPeople Find people

**Note:** this endpoint is available in Alfresco 5.2 and newer versions.

Gets a list of people that match the given search criteria.

The search term is used to look for matches against person id, firstname and lastname.

The search term:
- must contain a minimum of 2 alphanumeric characters
- can optionally use '*' for wildcard matching within the term

You can sort the result list using the **orderBy** parameter. You can specify one or more of the following fields in the **orderBy** parameter:
* id
* firstName
* lastName


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFindPeopleRequest
*/
func (a *QueriesApiService) FindPeople(ctx context.Context) ApiFindPeopleRequest {
	return ApiFindPeopleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PersonPaging
func (a *QueriesApiService) FindPeopleExecute(r ApiFindPeopleRequest) (*PersonPaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PersonPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueriesApiService.FindPeople")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queries/people"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.term == nil {
		return localVarReturnValue, nil, reportError("term is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "term", r.term, "")
	if r.skipCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipCount", r.skipCount, "")
	}
	if r.maxItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxItems", r.maxItems, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindSitesRequest struct {
	ctx context.Context
	ApiService *QueriesApiService
	term *string
	skipCount *int32
	maxItems *int32
	orderBy *[]string
	fields *[]string
}

// The term to search for.
func (r ApiFindSitesRequest) Term(term string) ApiFindSitesRequest {
	r.term = &term
	return r
}

// The number of entities that exist in the collection before those included in this list. If not supplied then the default value is 0. 
func (r ApiFindSitesRequest) SkipCount(skipCount int32) ApiFindSitesRequest {
	r.skipCount = &skipCount
	return r
}

// The maximum number of items to return in the list. If not supplied then the default value is 100. 
func (r ApiFindSitesRequest) MaxItems(maxItems int32) ApiFindSitesRequest {
	r.maxItems = &maxItems
	return r
}

// A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. 
func (r ApiFindSitesRequest) OrderBy(orderBy []string) ApiFindSitesRequest {
	r.orderBy = &orderBy
	return r
}

// A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. 
func (r ApiFindSitesRequest) Fields(fields []string) ApiFindSitesRequest {
	r.fields = &fields
	return r
}

func (r ApiFindSitesRequest) Execute() (*SitePaging, *http.Response, error) {
	return r.ApiService.FindSitesExecute(r)
}

/*
FindSites Find sites

**Note:** this endpoint is available in Alfresco 5.2 and newer versions.

Gets a list of sites that match the given search criteria.

The search term is used to look for sites that match against site id, title or description.

The search term:
- must contain a minimum of 2 alphanumeric characters
- can optionally use '*' for wildcard matching within the term

The default sort order for the returned list is for sites to be sorted by ascending id.
You can override the default by using the **orderBy** parameter. You can specify one or more of the following fields in the **orderBy** parameter:
* id
* title
* description


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFindSitesRequest
*/
func (a *QueriesApiService) FindSites(ctx context.Context) ApiFindSitesRequest {
	return ApiFindSitesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SitePaging
func (a *QueriesApiService) FindSitesExecute(r ApiFindSitesRequest) (*SitePaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SitePaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueriesApiService.FindSites")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queries/sites"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.term == nil {
		return localVarReturnValue, nil, reportError("term is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "term", r.term, "")
	if r.skipCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipCount", r.skipCount, "")
	}
	if r.maxItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxItems", r.maxItems, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "csv")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
