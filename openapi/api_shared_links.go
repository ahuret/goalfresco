/*
Alfresco Content Services REST API

**Core API**  Provides access to the core features of Alfresco Content Services. 

API version: 1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	"github.com/ahuret/goalfresco/time"
)


// SharedLinksApiService SharedLinksApi service
type SharedLinksApiService service

type ApiCreateSharedLinkRequest struct {
	ctx context.Context
	ApiService *SharedLinksApiService
	sharedLinkBodyCreate *SharedLinkBodyCreate
	include *[]string
	fields *[]string
}

// The nodeId to create a shared link for.
func (r ApiCreateSharedLinkRequest) SharedLinkBodyCreate(sharedLinkBodyCreate SharedLinkBodyCreate) ApiCreateSharedLinkRequest {
	r.sharedLinkBodyCreate = &sharedLinkBodyCreate
	return r
}

// Returns additional information about the shared link, the following optional fields can be requested: * allowableOperations * path * properties * isFavorite * aspectNames 
func (r ApiCreateSharedLinkRequest) Include(include []string) ApiCreateSharedLinkRequest {
	r.include = &include
	return r
}

// A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. 
func (r ApiCreateSharedLinkRequest) Fields(fields []string) ApiCreateSharedLinkRequest {
	r.fields = &fields
	return r
}

func (r ApiCreateSharedLinkRequest) Execute() (*SharedLinkEntry, *http.Response, error) {
	return r.ApiService.CreateSharedLinkExecute(r)
}

/*
CreateSharedLink Create a shared link to a file

**Note:** this endpoint is available in Alfresco 5.2 and newer versions.

Create a shared link to the file **nodeId** in the request body. Also, an optional expiry date could be set,
so the shared link would become invalid when the expiry date is reached. For example:

```JSON
  {
    "nodeId": "1ff9da1a-ee2f-4b9c-8c34-3333333333",
    "expiresAt": "2017-03-23T23:00:00.000+0000"
  }
```

**Note:** You can create shared links to more than one file
specifying a list of **nodeId**s in the JSON body like this:

```JSON
[
  {
    "nodeId": "1ff9da1a-ee2f-4b9c-8c34-4444444444"
  },
  {
    "nodeId": "1ff9da1a-ee2f-4b9c-8c34-5555555555"
  }
]
```
If you specify a list as input, then a paginated list rather than an entry is returned in the response body. For example:

```JSON
{
  "list": {
    "pagination": {
      "count": 2,
      "hasMoreItems": false,
      "totalItems": 2,
      "skipCount": 0,
      "maxItems": 100
    },
    "entries": [
      {
        "entry": {
          ...
        }
      },
      {
        "entry": {
          ...
        }
      }
    ]
  }
}
```


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSharedLinkRequest
*/
func (a *SharedLinksApiService) CreateSharedLink(ctx context.Context) ApiCreateSharedLinkRequest {
	return ApiCreateSharedLinkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SharedLinkEntry
func (a *SharedLinksApiService) CreateSharedLinkExecute(r ApiCreateSharedLinkRequest) (*SharedLinkEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharedLinkEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharedLinksApiService.CreateSharedLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shared-links"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sharedLinkBodyCreate == nil {
		return localVarReturnValue, nil, reportError("sharedLinkBodyCreate is required and must be specified")
	}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharedLinkBodyCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSharedLinkRequest struct {
	ctx context.Context
	ApiService *SharedLinksApiService
	sharedId string
}

func (r ApiDeleteSharedLinkRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSharedLinkExecute(r)
}

/*
DeleteSharedLink Deletes a shared link

**Note:** this endpoint is available in Alfresco 5.2 and newer versions.

Deletes the shared link with identifier **sharedId**.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedId The identifier of a shared link to a file.
 @return ApiDeleteSharedLinkRequest
*/
func (a *SharedLinksApiService) DeleteSharedLink(ctx context.Context, sharedId string) ApiDeleteSharedLinkRequest {
	return ApiDeleteSharedLinkRequest{
		ApiService: a,
		ctx: ctx,
		sharedId: sharedId,
	}
}

// Execute executes the request
func (a *SharedLinksApiService) DeleteSharedLinkExecute(r ApiDeleteSharedLinkRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharedLinksApiService.DeleteSharedLink")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shared-links/{sharedId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedId"+"}", url.PathEscape(parameterValueToString(r.sharedId, "sharedId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEmailSharedLinkRequest struct {
	ctx context.Context
	ApiService *SharedLinksApiService
	sharedId string
	sharedLinkBodyEmail *SharedLinkBodyEmail
}

// The shared link email to send.
func (r ApiEmailSharedLinkRequest) SharedLinkBodyEmail(sharedLinkBodyEmail SharedLinkBodyEmail) ApiEmailSharedLinkRequest {
	r.sharedLinkBodyEmail = &sharedLinkBodyEmail
	return r
}

func (r ApiEmailSharedLinkRequest) Execute() (*http.Response, error) {
	return r.ApiService.EmailSharedLinkExecute(r)
}

/*
EmailSharedLink Email shared link

**Note:** this endpoint is available in Alfresco 5.2 and newer versions.

Sends email with app-specific url including identifier **sharedId**.

The client and recipientEmails properties are mandatory in the request body. For example, to email a shared link with minimum info:
```JSON
{
    "client": "myClient",
    "recipientEmails": ["john.doe@acme.com", "joe.bloggs@acme.com"]
}
```
A plain text message property can be optionally provided in the request body to customise the sent email.
Also, a locale property can be optionally provided in the request body to send the emails in a particular language (if the locale is supported by Alfresco).
For example, to email a shared link with a messages and a locale:
```JSON
{
    "client": "myClient",
    "recipientEmails": ["john.doe@acme.com", "joe.bloggs@acme.com"],
    "message": "myMessage",
    "locale":"en-GB"
}
```
**Note:** The client must be registered before you can send a shared link email. See [server documentation]. However, out-of-the-box
 share is registered as a default client, so you could pass **share** as the client name:
```JSON
{
    "client": "share",
    "recipientEmails": ["john.doe@acme.com"]
}
```


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedId The identifier of a shared link to a file.
 @return ApiEmailSharedLinkRequest
*/
func (a *SharedLinksApiService) EmailSharedLink(ctx context.Context, sharedId string) ApiEmailSharedLinkRequest {
	return ApiEmailSharedLinkRequest{
		ApiService: a,
		ctx: ctx,
		sharedId: sharedId,
	}
}

// Execute executes the request
func (a *SharedLinksApiService) EmailSharedLinkExecute(r ApiEmailSharedLinkRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharedLinksApiService.EmailSharedLink")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shared-links/{sharedId}/email"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedId"+"}", url.PathEscape(parameterValueToString(r.sharedId, "sharedId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sharedLinkBodyEmail == nil {
		return nil, reportError("sharedLinkBodyEmail is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharedLinkBodyEmail
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSharedLinkRequest struct {
	ctx context.Context
	ApiService *SharedLinksApiService
	sharedId string
	fields *[]string
}

// A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. 
func (r ApiGetSharedLinkRequest) Fields(fields []string) ApiGetSharedLinkRequest {
	r.fields = &fields
	return r
}

func (r ApiGetSharedLinkRequest) Execute() (*SharedLinkEntry, *http.Response, error) {
	return r.ApiService.GetSharedLinkExecute(r)
}

/*
GetSharedLink Get a shared link

**Note:** this endpoint is available in Alfresco 5.2 and newer versions.

Gets minimal information for the file with shared link identifier **sharedId**.

**Note:** No authentication is required to call this endpoint.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedId The identifier of a shared link to a file.
 @return ApiGetSharedLinkRequest
*/
func (a *SharedLinksApiService) GetSharedLink(ctx context.Context, sharedId string) ApiGetSharedLinkRequest {
	return ApiGetSharedLinkRequest{
		ApiService: a,
		ctx: ctx,
		sharedId: sharedId,
	}
}

// Execute executes the request
//  @return SharedLinkEntry
func (a *SharedLinksApiService) GetSharedLinkExecute(r ApiGetSharedLinkRequest) (*SharedLinkEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharedLinkEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharedLinksApiService.GetSharedLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shared-links/{sharedId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedId"+"}", url.PathEscape(parameterValueToString(r.sharedId, "sharedId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSharedLinkContentRequest struct {
	ctx context.Context
	ApiService *SharedLinksApiService
	sharedId string
	attachment *bool
	ifModifiedSince *time.Time
	range_ *string
}

// **true** enables a web browser to download the file as an attachment. **false** means a web browser may preview the file in a new tab or window, but not download the file.  You can only set this parameter to **false** if the content type of the file is in the supported list; for example, certain image files and PDF files.  If the content type is not supported for preview, then a value of **false**  is ignored, and the attachment will be returned in the response. 
func (r ApiGetSharedLinkContentRequest) Attachment(attachment bool) ApiGetSharedLinkContentRequest {
	r.attachment = &attachment
	return r
}

// Only returns the content if it has been modified since the date provided. Use the date format defined by HTTP. For example, &#x60;Wed, 09 Mar 2016 16:56:34 GMT&#x60;. 
func (r ApiGetSharedLinkContentRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetSharedLinkContentRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// The Range header indicates the part of a document that the server should return. Single part request supported, for example: bytes&#x3D;1-10. 
func (r ApiGetSharedLinkContentRequest) Range_(range_ string) ApiGetSharedLinkContentRequest {
	r.range_ = &range_
	return r
}

func (r ApiGetSharedLinkContentRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetSharedLinkContentExecute(r)
}

/*
GetSharedLinkContent Get shared link content

**Note:** this endpoint is available in Alfresco 5.2 and newer versions.

Gets the content of the file with shared link identifier **sharedId**.

**Note:** No authentication is required to call this endpoint.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedId The identifier of a shared link to a file.
 @return ApiGetSharedLinkContentRequest
*/
func (a *SharedLinksApiService) GetSharedLinkContent(ctx context.Context, sharedId string) ApiGetSharedLinkContentRequest {
	return ApiGetSharedLinkContentRequest{
		ApiService: a,
		ctx: ctx,
		sharedId: sharedId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *SharedLinksApiService) GetSharedLinkContentExecute(r ApiGetSharedLinkContentRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharedLinksApiService.GetSharedLinkContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shared-links/{sharedId}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedId"+"}", url.PathEscape(parameterValueToString(r.sharedId, "sharedId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.attachment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachment", r.attachment, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Range", r.range_, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSharedLinkRenditionRequest struct {
	ctx context.Context
	ApiService *SharedLinksApiService
	sharedId string
	renditionId string
}

func (r ApiGetSharedLinkRenditionRequest) Execute() (*RenditionEntry, *http.Response, error) {
	return r.ApiService.GetSharedLinkRenditionExecute(r)
}

/*
GetSharedLinkRendition Get shared link rendition information

**Note:** this endpoint is available in Alfresco 5.2 and newer versions.

Gets rendition information for the file with shared link identifier **sharedId**.

This API method returns rendition information where the rendition status is CREATED,
which means the rendition is availableÂ to view/download.

**Note:** No authentication is required to call this endpoint.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedId The identifier of a shared link to a file.
 @param renditionId The name of a thumbnail rendition, for example *doclib*, or *pdf*.
 @return ApiGetSharedLinkRenditionRequest
*/
func (a *SharedLinksApiService) GetSharedLinkRendition(ctx context.Context, sharedId string, renditionId string) ApiGetSharedLinkRenditionRequest {
	return ApiGetSharedLinkRenditionRequest{
		ApiService: a,
		ctx: ctx,
		sharedId: sharedId,
		renditionId: renditionId,
	}
}

// Execute executes the request
//  @return RenditionEntry
func (a *SharedLinksApiService) GetSharedLinkRenditionExecute(r ApiGetSharedLinkRenditionRequest) (*RenditionEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RenditionEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharedLinksApiService.GetSharedLinkRendition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shared-links/{sharedId}/renditions/{renditionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedId"+"}", url.PathEscape(parameterValueToString(r.sharedId, "sharedId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"renditionId"+"}", url.PathEscape(parameterValueToString(r.renditionId, "renditionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSharedLinkRenditionContentRequest struct {
	ctx context.Context
	ApiService *SharedLinksApiService
	sharedId string
	renditionId string
	attachment *bool
	ifModifiedSince *time.Time
	range_ *string
}

// **true** enables a web browser to download the file as an attachment. **false** means a web browser may preview the file in a new tab or window, but not download the file.  You can only set this parameter to **false** if the content type of the file is in the supported list; for example, certain image files and PDF files.  If the content type is not supported for preview, then a value of **false**  is ignored, and the attachment will be returned in the response. 
func (r ApiGetSharedLinkRenditionContentRequest) Attachment(attachment bool) ApiGetSharedLinkRenditionContentRequest {
	r.attachment = &attachment
	return r
}

// Only returns the content if it has been modified since the date provided. Use the date format defined by HTTP. For example, &#x60;Wed, 09 Mar 2016 16:56:34 GMT&#x60;. 
func (r ApiGetSharedLinkRenditionContentRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetSharedLinkRenditionContentRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// The Range header indicates the part of a document that the server should return. Single part request supported, for example: bytes&#x3D;1-10. 
func (r ApiGetSharedLinkRenditionContentRequest) Range_(range_ string) ApiGetSharedLinkRenditionContentRequest {
	r.range_ = &range_
	return r
}

func (r ApiGetSharedLinkRenditionContentRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetSharedLinkRenditionContentExecute(r)
}

/*
GetSharedLinkRenditionContent Get shared link rendition content

**Note:** this endpoint is available in Alfresco 5.2 and newer versions.

Gets the rendition content for file with shared link identifier **sharedId**.

**Note:** No authentication is required to call this endpoint.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedId The identifier of a shared link to a file.
 @param renditionId The name of a thumbnail rendition, for example *doclib*, or *pdf*.
 @return ApiGetSharedLinkRenditionContentRequest
*/
func (a *SharedLinksApiService) GetSharedLinkRenditionContent(ctx context.Context, sharedId string, renditionId string) ApiGetSharedLinkRenditionContentRequest {
	return ApiGetSharedLinkRenditionContentRequest{
		ApiService: a,
		ctx: ctx,
		sharedId: sharedId,
		renditionId: renditionId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *SharedLinksApiService) GetSharedLinkRenditionContentExecute(r ApiGetSharedLinkRenditionContentRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharedLinksApiService.GetSharedLinkRenditionContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shared-links/{sharedId}/renditions/{renditionId}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedId"+"}", url.PathEscape(parameterValueToString(r.sharedId, "sharedId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"renditionId"+"}", url.PathEscape(parameterValueToString(r.renditionId, "renditionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.attachment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachment", r.attachment, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Range", r.range_, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSharedLinkRenditionsRequest struct {
	ctx context.Context
	ApiService *SharedLinksApiService
	sharedId string
}

func (r ApiListSharedLinkRenditionsRequest) Execute() (*RenditionPaging, *http.Response, error) {
	return r.ApiService.ListSharedLinkRenditionsExecute(r)
}

/*
ListSharedLinkRenditions List renditions for a shared link

**Note:** this endpoint is available in Alfresco 5.2 and newer versions.

Gets a list of the rendition information for the file with shared link identifier **sharedId**.

This API method returns rendition information, including the rendition id, for each rendition
where the rendition status is CREATED, which means the rendition is availableÂ to view/download.

**Note:** No authentication is required to call this endpoint.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedId The identifier of a shared link to a file.
 @return ApiListSharedLinkRenditionsRequest
*/
func (a *SharedLinksApiService) ListSharedLinkRenditions(ctx context.Context, sharedId string) ApiListSharedLinkRenditionsRequest {
	return ApiListSharedLinkRenditionsRequest{
		ApiService: a,
		ctx: ctx,
		sharedId: sharedId,
	}
}

// Execute executes the request
//  @return RenditionPaging
func (a *SharedLinksApiService) ListSharedLinkRenditionsExecute(r ApiListSharedLinkRenditionsRequest) (*RenditionPaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RenditionPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharedLinksApiService.ListSharedLinkRenditions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shared-links/{sharedId}/renditions"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedId"+"}", url.PathEscape(parameterValueToString(r.sharedId, "sharedId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSharedLinksRequest struct {
	ctx context.Context
	ApiService *SharedLinksApiService
	skipCount *int32
	maxItems *int32
	where *string
	include *[]string
	fields *[]string
}

// The number of entities that exist in the collection before those included in this list. If not supplied then the default value is 0. 
func (r ApiListSharedLinksRequest) SkipCount(skipCount int32) ApiListSharedLinksRequest {
	r.skipCount = &skipCount
	return r
}

// The maximum number of items to return in the list. If not supplied then the default value is 100. 
func (r ApiListSharedLinksRequest) MaxItems(maxItems int32) ApiListSharedLinksRequest {
	r.maxItems = &maxItems
	return r
}

// Optionally filter the list by \&quot;sharedByUser\&quot; userid of person who shared the link (can also use -me-)  *   &#x60;&#x60;&#x60;where&#x3D;(sharedByUser&#x3D;&#39;jbloggs&#39;)&#x60;&#x60;&#x60;  *   &#x60;&#x60;&#x60;where&#x3D;(sharedByUser&#x3D;&#39;-me-&#39;)&#x60;&#x60;&#x60; 
func (r ApiListSharedLinksRequest) Where(where string) ApiListSharedLinksRequest {
	r.where = &where
	return r
}

// Returns additional information about the shared link, the following optional fields can be requested: * allowableOperations * path * properties * isFavorite * aspectNames 
func (r ApiListSharedLinksRequest) Include(include []string) ApiListSharedLinksRequest {
	r.include = &include
	return r
}

// A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. 
func (r ApiListSharedLinksRequest) Fields(fields []string) ApiListSharedLinksRequest {
	r.fields = &fields
	return r
}

func (r ApiListSharedLinksRequest) Execute() (*SharedLinkPaging, *http.Response, error) {
	return r.ApiService.ListSharedLinksExecute(r)
}

/*
ListSharedLinks List shared links

**Note:** this endpoint is available in Alfresco 5.2 and newer versions.

Get a list of links that the current user has read permission on source node.

The list is ordered in descending modified order.

**Note:** The list of links is eventually consistent so newly created shared links may not appear immediately.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSharedLinksRequest
*/
func (a *SharedLinksApiService) ListSharedLinks(ctx context.Context) ApiListSharedLinksRequest {
	return ApiListSharedLinksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SharedLinkPaging
func (a *SharedLinksApiService) ListSharedLinksExecute(r ApiListSharedLinksRequest) (*SharedLinkPaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharedLinkPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharedLinksApiService.ListSharedLinks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shared-links"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.skipCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipCount", r.skipCount, "")
	}
	if r.maxItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxItems", r.maxItems, "")
	}
	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
