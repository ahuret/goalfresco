/*
Alfresco Content Services REST API

**Core API**  Provides access to the core features of Alfresco Content Services. 

API version: 1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AuditApiService AuditApi service
type AuditApiService service

type ApiDeleteAuditEntriesForAuditAppRequest struct {
	ctx context.Context
	ApiService *AuditApiService
	auditApplicationId string
	where *string
}

// Audit entries to permanently delete for an audit application, given an inclusive time period or range of ids. For example:  *   &#x60;&#x60;&#x60;where&#x3D;(createdAt BETWEEN (&#39;2017-06-02T12:13:51.593+01:00&#39; , &#39;2017-06-04T10:05:16.536+01:00&#39;)&#x60;&#x60;&#x60; *   &#x60;&#x60;&#x60;where&#x3D;(id BETWEEN (&#39;1234&#39;, &#39;4321&#39;)&#x60;&#x60;&#x60; 
func (r ApiDeleteAuditEntriesForAuditAppRequest) Where(where string) ApiDeleteAuditEntriesForAuditAppRequest {
	r.where = &where
	return r
}

func (r ApiDeleteAuditEntriesForAuditAppRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAuditEntriesForAuditAppExecute(r)
}

/*
DeleteAuditEntriesForAuditApp Permanently delete audit entries for an audit application

**Note:** this endpoint is available in Alfresco 5.2.2 and newer versions.

Permanently delete audit entries for an audit application **auditApplicationId**.

The **where** clause must be specified, either with an inclusive time period or for
an inclusive range of ids. The delete is within the context of the given audit application.

For example:

*   ```where=(createdAt BETWEEN ('2017-06-02T12:13:51.593+01:00' , '2017-06-04T10:05:16.536+01:00')```
*   ```where=(id BETWEEN ('1234', '4321')```

You must have admin rights to delete audit information.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param auditApplicationId The identifier of an audit application.
 @return ApiDeleteAuditEntriesForAuditAppRequest
*/
func (a *AuditApiService) DeleteAuditEntriesForAuditApp(ctx context.Context, auditApplicationId string) ApiDeleteAuditEntriesForAuditAppRequest {
	return ApiDeleteAuditEntriesForAuditAppRequest{
		ApiService: a,
		ctx: ctx,
		auditApplicationId: auditApplicationId,
	}
}

// Execute executes the request
func (a *AuditApiService) DeleteAuditEntriesForAuditAppExecute(r ApiDeleteAuditEntriesForAuditAppRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditApiService.DeleteAuditEntriesForAuditApp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audit-applications/{auditApplicationId}/audit-entries"
	localVarPath = strings.Replace(localVarPath, "{"+"auditApplicationId"+"}", url.PathEscape(parameterValueToString(r.auditApplicationId, "auditApplicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.where == nil {
		return nil, reportError("where is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAuditEntryRequest struct {
	ctx context.Context
	ApiService *AuditApiService
	auditApplicationId string
	auditEntryId string
}

func (r ApiDeleteAuditEntryRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAuditEntryExecute(r)
}

/*
DeleteAuditEntry Permanently delete an audit entry

**Note:** this endpoint is available in Alfresco 5.2.2 and newer versions.

Permanently delete a single audit entry **auditEntryId**.

You must have admin rights to delete audit information.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param auditApplicationId The identifier of an audit application.
 @param auditEntryId The identifier of an audit entry.
 @return ApiDeleteAuditEntryRequest
*/
func (a *AuditApiService) DeleteAuditEntry(ctx context.Context, auditApplicationId string, auditEntryId string) ApiDeleteAuditEntryRequest {
	return ApiDeleteAuditEntryRequest{
		ApiService: a,
		ctx: ctx,
		auditApplicationId: auditApplicationId,
		auditEntryId: auditEntryId,
	}
}

// Execute executes the request
func (a *AuditApiService) DeleteAuditEntryExecute(r ApiDeleteAuditEntryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditApiService.DeleteAuditEntry")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audit-applications/{auditApplicationId}/audit-entries/{auditEntryId}"
	localVarPath = strings.Replace(localVarPath, "{"+"auditApplicationId"+"}", url.PathEscape(parameterValueToString(r.auditApplicationId, "auditApplicationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"auditEntryId"+"}", url.PathEscape(parameterValueToString(r.auditEntryId, "auditEntryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAuditAppRequest struct {
	ctx context.Context
	ApiService *AuditApiService
	auditApplicationId string
	fields *[]string
	include *[]string
}

// A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. 
func (r ApiGetAuditAppRequest) Fields(fields []string) ApiGetAuditAppRequest {
	r.fields = &fields
	return r
}

// Also include the current minimum and/or maximum audit entry ids for the application. The following optional fields can be requested: * max * min 
func (r ApiGetAuditAppRequest) Include(include []string) ApiGetAuditAppRequest {
	r.include = &include
	return r
}

func (r ApiGetAuditAppRequest) Execute() (*AuditApp, *http.Response, error) {
	return r.ApiService.GetAuditAppExecute(r)
}

/*
GetAuditApp Get audit application info

**Note:** this endpoint is available in Alfresco 5.2.2 and newer versions.

Get status of an audit application **auditApplicationId**.

You must have admin rights to retrieve audit information.

You can use the **include** parameter to return the minimum and/or maximum audit record id for the application.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param auditApplicationId The identifier of an audit application.
 @return ApiGetAuditAppRequest
*/
func (a *AuditApiService) GetAuditApp(ctx context.Context, auditApplicationId string) ApiGetAuditAppRequest {
	return ApiGetAuditAppRequest{
		ApiService: a,
		ctx: ctx,
		auditApplicationId: auditApplicationId,
	}
}

// Execute executes the request
//  @return AuditApp
func (a *AuditApiService) GetAuditAppExecute(r ApiGetAuditAppRequest) (*AuditApp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuditApp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditApiService.GetAuditApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audit-applications/{auditApplicationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"auditApplicationId"+"}", url.PathEscape(parameterValueToString(r.auditApplicationId, "auditApplicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAuditEntryRequest struct {
	ctx context.Context
	ApiService *AuditApiService
	auditApplicationId string
	auditEntryId string
	fields *[]string
}

// A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. 
func (r ApiGetAuditEntryRequest) Fields(fields []string) ApiGetAuditEntryRequest {
	r.fields = &fields
	return r
}

func (r ApiGetAuditEntryRequest) Execute() (*AuditEntryEntry, *http.Response, error) {
	return r.ApiService.GetAuditEntryExecute(r)
}

/*
GetAuditEntry Get audit entry

**Note:** this endpoint is available in Alfresco 5.2.2 and newer versions.

Gets audit entry **auditEntryId**.

You must have admin rights to access audit information.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param auditApplicationId The identifier of an audit application.
 @param auditEntryId The identifier of an audit entry.
 @return ApiGetAuditEntryRequest
*/
func (a *AuditApiService) GetAuditEntry(ctx context.Context, auditApplicationId string, auditEntryId string) ApiGetAuditEntryRequest {
	return ApiGetAuditEntryRequest{
		ApiService: a,
		ctx: ctx,
		auditApplicationId: auditApplicationId,
		auditEntryId: auditEntryId,
	}
}

// Execute executes the request
//  @return AuditEntryEntry
func (a *AuditApiService) GetAuditEntryExecute(r ApiGetAuditEntryRequest) (*AuditEntryEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuditEntryEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditApiService.GetAuditEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audit-applications/{auditApplicationId}/audit-entries/{auditEntryId}"
	localVarPath = strings.Replace(localVarPath, "{"+"auditApplicationId"+"}", url.PathEscape(parameterValueToString(r.auditApplicationId, "auditApplicationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"auditEntryId"+"}", url.PathEscape(parameterValueToString(r.auditEntryId, "auditEntryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAuditAppsRequest struct {
	ctx context.Context
	ApiService *AuditApiService
	skipCount *int32
	maxItems *int32
	fields *[]string
}

// The number of entities that exist in the collection before those included in this list. If not supplied then the default value is 0. 
func (r ApiListAuditAppsRequest) SkipCount(skipCount int32) ApiListAuditAppsRequest {
	r.skipCount = &skipCount
	return r
}

// The maximum number of items to return in the list. If not supplied then the default value is 100. 
func (r ApiListAuditAppsRequest) MaxItems(maxItems int32) ApiListAuditAppsRequest {
	r.maxItems = &maxItems
	return r
}

// A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. 
func (r ApiListAuditAppsRequest) Fields(fields []string) ApiListAuditAppsRequest {
	r.fields = &fields
	return r
}

func (r ApiListAuditAppsRequest) Execute() (*AuditAppPaging, *http.Response, error) {
	return r.ApiService.ListAuditAppsExecute(r)
}

/*
ListAuditApps List audit applications

**Note:** this endpoint is available in Alfresco 5.2.2 and newer versions.

Gets a list of audit applications in this repository.

This list may include pre-configured audit applications, if enabled, such as:

* alfresco-access
* CMISChangeLog
* Alfresco Tagging Service
* Alfresco Sync Service (used by Enterprise Cloud Sync)

You must have admin rights to retrieve audit information.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAuditAppsRequest
*/
func (a *AuditApiService) ListAuditApps(ctx context.Context) ApiListAuditAppsRequest {
	return ApiListAuditAppsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuditAppPaging
func (a *AuditApiService) ListAuditAppsExecute(r ApiListAuditAppsRequest) (*AuditAppPaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuditAppPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditApiService.ListAuditApps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audit-applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.skipCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipCount", r.skipCount, "")
	}
	if r.maxItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxItems", r.maxItems, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAuditEntriesForAuditAppRequest struct {
	ctx context.Context
	ApiService *AuditApiService
	auditApplicationId string
	skipCount *int32
	omitTotalItems *bool
	orderBy *[]string
	maxItems *int32
	where *string
	include *[]string
	fields *[]string
}

// The number of entities that exist in the collection before those included in this list. If not supplied then the default value is 0. 
func (r ApiListAuditEntriesForAuditAppRequest) SkipCount(skipCount int32) ApiListAuditEntriesForAuditAppRequest {
	r.skipCount = &skipCount
	return r
}

// A boolean to control if the response provides the total numbers of items in the collection. If not supplied then the default value is false. 
func (r ApiListAuditEntriesForAuditAppRequest) OmitTotalItems(omitTotalItems bool) ApiListAuditEntriesForAuditAppRequest {
	r.omitTotalItems = &omitTotalItems
	return r
}

// A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. 
func (r ApiListAuditEntriesForAuditAppRequest) OrderBy(orderBy []string) ApiListAuditEntriesForAuditAppRequest {
	r.orderBy = &orderBy
	return r
}

// The maximum number of items to return in the list. If not supplied then the default value is 100. 
func (r ApiListAuditEntriesForAuditAppRequest) MaxItems(maxItems int32) ApiListAuditEntriesForAuditAppRequest {
	r.maxItems = &maxItems
	return r
}

// Optionally filter the list. Here are some examples:  *   &#x60;&#x60;&#x60;where&#x3D;(createdByUser&#x3D;&#39;jbloggs&#39;)&#x60;&#x60;&#x60;  *   &#x60;&#x60;&#x60;where&#x3D;(id BETWEEN (&#39;1234&#39;, &#39;4321&#39;)&#x60;&#x60;&#x60;  *   &#x60;&#x60;&#x60;where&#x3D;(createdAt BETWEEN (&#39;2017-06-02T12:13:51.593+01:00&#39; , &#39;2017-06-04T10:05:16.536+01:00&#39;)&#x60;&#x60;&#x60;  *   &#x60;&#x60;&#x60;where&#x3D;(createdByUser&#x3D;&#39;jbloggs&#39; and createdAt BETWEEN (&#39;2017-06-02T12:13:51.593+01:00&#39; , &#39;2017-06-04T10:05:16.536+01:00&#39;)&#x60;&#x60;&#x60;  *   &#x60;&#x60;&#x60;where&#x3D;(valuesKey&#x3D;&#39;/alfresco-access/login/user&#39;)&#x60;&#x60;&#x60;  *   &#x60;&#x60;&#x60;where&#x3D;(valuesKey&#x3D;&#39;/alfresco-access/transaction/action&#39; and valuesValue&#x3D;&#39;DELETE&#39;)&#x60;&#x60;&#x60; 
func (r ApiListAuditEntriesForAuditAppRequest) Where(where string) ApiListAuditEntriesForAuditAppRequest {
	r.where = &where
	return r
}

// Returns additional information about the audit entry. The following optional fields can be requested: * values 
func (r ApiListAuditEntriesForAuditAppRequest) Include(include []string) ApiListAuditEntriesForAuditAppRequest {
	r.include = &include
	return r
}

// A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. 
func (r ApiListAuditEntriesForAuditAppRequest) Fields(fields []string) ApiListAuditEntriesForAuditAppRequest {
	r.fields = &fields
	return r
}

func (r ApiListAuditEntriesForAuditAppRequest) Execute() (*AuditEntryPaging, *http.Response, error) {
	return r.ApiService.ListAuditEntriesForAuditAppExecute(r)
}

/*
ListAuditEntriesForAuditApp List audit entries for an audit application

**Note:** this endpoint is available in Alfresco 5.2.2 and newer versions.

Gets a list of audit entries for audit application **auditApplicationId**.

You can use the **include** parameter to return additional **values** information.

The list can be filtered by one or more of:
* **createdByUser** person id
* **createdAt** inclusive time period
* **id** inclusive range of ids
* **valuesKey** audit entry values contains the exact matching key
* **valuesValue** audit entry values contains the exact matching value

The default sort order is **createdAt** ascending, but you can use an optional **ASC** or **DESC**
modifier to specify an ascending or descending sort order.

For example, specifying ```orderBy=createdAt DESC``` returns audit entries in descending **createdAt** order.

You must have admin rights to retrieve audit information.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param auditApplicationId The identifier of an audit application.
 @return ApiListAuditEntriesForAuditAppRequest
*/
func (a *AuditApiService) ListAuditEntriesForAuditApp(ctx context.Context, auditApplicationId string) ApiListAuditEntriesForAuditAppRequest {
	return ApiListAuditEntriesForAuditAppRequest{
		ApiService: a,
		ctx: ctx,
		auditApplicationId: auditApplicationId,
	}
}

// Execute executes the request
//  @return AuditEntryPaging
func (a *AuditApiService) ListAuditEntriesForAuditAppExecute(r ApiListAuditEntriesForAuditAppRequest) (*AuditEntryPaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuditEntryPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditApiService.ListAuditEntriesForAuditApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audit-applications/{auditApplicationId}/audit-entries"
	localVarPath = strings.Replace(localVarPath, "{"+"auditApplicationId"+"}", url.PathEscape(parameterValueToString(r.auditApplicationId, "auditApplicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.skipCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipCount", r.skipCount, "")
	}
	if r.omitTotalItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omitTotalItems", r.omitTotalItems, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "csv")
	}
	if r.maxItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxItems", r.maxItems, "")
	}
	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAuditEntriesForNodeRequest struct {
	ctx context.Context
	ApiService *AuditApiService
	nodeId string
	skipCount *int32
	orderBy *[]string
	maxItems *int32
	where *string
	include *[]string
	fields *[]string
}

// The number of entities that exist in the collection before those included in this list. If not supplied then the default value is 0. 
func (r ApiListAuditEntriesForNodeRequest) SkipCount(skipCount int32) ApiListAuditEntriesForNodeRequest {
	r.skipCount = &skipCount
	return r
}

// A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. 
func (r ApiListAuditEntriesForNodeRequest) OrderBy(orderBy []string) ApiListAuditEntriesForNodeRequest {
	r.orderBy = &orderBy
	return r
}

// The maximum number of items to return in the list. If not supplied then the default value is 100. 
func (r ApiListAuditEntriesForNodeRequest) MaxItems(maxItems int32) ApiListAuditEntriesForNodeRequest {
	r.maxItems = &maxItems
	return r
}

// Optionally filter the list. Here are some examples:  *   &#x60;&#x60;&#x60;where&#x3D;(createdByUser&#x3D;&#39;-me-&#39;)&#x60;&#x60;&#x60;  *   &#x60;&#x60;&#x60;where&#x3D;(createdAt BETWEEN (&#39;2017-06-02T12:13:51.593+01:00&#39; , &#39;2017-06-04T10:05:16.536+01:00&#39;)&#x60;&#x60;&#x60;  *   &#x60;&#x60;&#x60;where&#x3D;(createdByUser&#x3D;&#39;jbloggs&#39; and createdAt BETWEEN (&#39;2017-06-02T12:13:51.593+01:00&#39; , &#39;2017-06-04T10:05:16.536+01:00&#39;)&#x60;&#x60;&#x60; 
func (r ApiListAuditEntriesForNodeRequest) Where(where string) ApiListAuditEntriesForNodeRequest {
	r.where = &where
	return r
}

// Returns additional information about the audit entry. The following optional fields can be requested: * values 
func (r ApiListAuditEntriesForNodeRequest) Include(include []string) ApiListAuditEntriesForNodeRequest {
	r.include = &include
	return r
}

// A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. 
func (r ApiListAuditEntriesForNodeRequest) Fields(fields []string) ApiListAuditEntriesForNodeRequest {
	r.fields = &fields
	return r
}

func (r ApiListAuditEntriesForNodeRequest) Execute() (*AuditEntryPaging, *http.Response, error) {
	return r.ApiService.ListAuditEntriesForNodeExecute(r)
}

/*
ListAuditEntriesForNode List audit entries for a node

**Note:** this endpoint is available in Alfresco 5.2.2 and newer versions.

Gets a list of audit entries for node **nodeId**.

The list can be filtered by **createdByUser** and for a given inclusive time period.

The default sort order is **createdAt** ascending, but you can use an optional **ASC** or **DESC**
modifier to specify an ascending or descending sort order.

For example, specifying ```orderBy=createdAt DESC``` returns audit entries in descending **createdAt** order.

This relies on the pre-configured 'alfresco-access' audit application.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId The identifier of a node.
 @return ApiListAuditEntriesForNodeRequest
*/
func (a *AuditApiService) ListAuditEntriesForNode(ctx context.Context, nodeId string) ApiListAuditEntriesForNodeRequest {
	return ApiListAuditEntriesForNodeRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return AuditEntryPaging
func (a *AuditApiService) ListAuditEntriesForNodeExecute(r ApiListAuditEntriesForNodeRequest) (*AuditEntryPaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuditEntryPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditApiService.ListAuditEntriesForNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{nodeId}/audit-entries"
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.skipCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipCount", r.skipCount, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "csv")
	}
	if r.maxItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxItems", r.maxItems, "")
	}
	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAuditAppRequest struct {
	ctx context.Context
	ApiService *AuditApiService
	auditApplicationId string
	auditAppBodyUpdate *AuditBodyUpdate
	fields *[]string
}

// The audit application to update.
func (r ApiUpdateAuditAppRequest) AuditAppBodyUpdate(auditAppBodyUpdate AuditBodyUpdate) ApiUpdateAuditAppRequest {
	r.auditAppBodyUpdate = &auditAppBodyUpdate
	return r
}

// A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. 
func (r ApiUpdateAuditAppRequest) Fields(fields []string) ApiUpdateAuditAppRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateAuditAppRequest) Execute() (*AuditApp, *http.Response, error) {
	return r.ApiService.UpdateAuditAppExecute(r)
}

/*
UpdateAuditApp Update audit application info

**Note:** this endpoint is available in Alfresco 5.2.2 and newer versions.

Disable or re-enable the audit application **auditApplicationId**.

New audit entries will not be created for a disabled audit application until
it is re-enabled (and system-wide auditing is also enabled).

Note, it is still possible to query &/or delete any existing audit entries even
if auditing is disabled for the audit application.

You must have admin rights to update audit application.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param auditApplicationId The identifier of an audit application.
 @return ApiUpdateAuditAppRequest
*/
func (a *AuditApiService) UpdateAuditApp(ctx context.Context, auditApplicationId string) ApiUpdateAuditAppRequest {
	return ApiUpdateAuditAppRequest{
		ApiService: a,
		ctx: ctx,
		auditApplicationId: auditApplicationId,
	}
}

// Execute executes the request
//  @return AuditApp
func (a *AuditApiService) UpdateAuditAppExecute(r ApiUpdateAuditAppRequest) (*AuditApp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuditApp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditApiService.UpdateAuditApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audit-applications/{auditApplicationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"auditApplicationId"+"}", url.PathEscape(parameterValueToString(r.auditApplicationId, "auditApplicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.auditAppBodyUpdate == nil {
		return localVarReturnValue, nil, reportError("auditAppBodyUpdate is required and must be specified")
	}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.auditAppBodyUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
